{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import{EventEmitter,Platform}from'@unimodules/core';import{_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS}from\"../AV\";import ExponentAV from\"../ExponentAV\";import{isAudioEnabled,throwIfAudioIsDisabled}from\"./AudioAvailability\";import{Sound}from\"./Sound\";export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT=0;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP=1;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4=2;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB=3;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB=4;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF=5;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS=6;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP=7;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS=8;export var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM=9;export var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT=0;export var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB=1;export var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB=2;export var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC=3;export var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC=4;export var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD=5;export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM='lpcm';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3='ac-3';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3='cac3';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4='ima4';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC='aac ';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP='celp';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC='hvxc';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ='twvq';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3='MAC3';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6='MAC6';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW='ulaw';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW='alaw';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN='QDMC';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2='QDM2';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM='Qclp';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1='.mp1';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2='.mp2';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3='.mp3';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS='alac';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE='aach';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD='aacl';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD='aace';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR='aacf';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2='aacg';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2='aacp';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL='aacs';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR='samr';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB='sawb';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE='AUDB';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC='ilbc';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA=0x6d730011;export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM=0x6d730031;export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3='aes3';export var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3='ec-3';export var RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN=0;export var RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW=0x20;export var RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM=0x40;export var RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH=0x60;export var RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX=0x7f;export var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT=0;export var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE=1;export var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED=2;export var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE=3;export var RECORDING_OPTIONS_PRESET_HIGH_QUALITY={android:{extension:'.m4a',outputFormat:RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,audioEncoder:RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,sampleRate:44100,numberOfChannels:2,bitRate:128000},ios:{extension:'.caf',audioQuality:RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,sampleRate:44100,numberOfChannels:2,bitRate:128000,linearPCMBitDepth:16,linearPCMIsBigEndian:false,linearPCMIsFloat:false}};export var RECORDING_OPTIONS_PRESET_LOW_QUALITY={android:{extension:'.3gp',outputFormat:RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,audioEncoder:RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,sampleRate:44100,numberOfChannels:2,bitRate:128000},ios:{extension:'.caf',audioQuality:RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,sampleRate:44100,numberOfChannels:2,bitRate:128000,linearPCMBitDepth:16,linearPCMIsBigEndian:false,linearPCMIsFloat:false}};var _recorderExists=false;var eventEmitter=Platform.OS==='android'?new EventEmitter(ExponentAV):null;export var Recording=function(){function Recording(){var _this=this;_classCallCheck(this,Recording);this._subscription=null;this._canRecord=false;this._isDoneRecording=false;this._finalDurationMillis=0;this._uri=null;this._onRecordingStatusUpdate=null;this._progressUpdateTimeoutVariable=null;this._progressUpdateIntervalMillis=_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;this._options=null;this._cleanupForUnloadedRecorder=function _callee(finalStatus){return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_this._canRecord=false;_this._isDoneRecording=true;_this._finalDurationMillis=finalStatus.durationMillis;_recorderExists=false;if(_this._subscription){_this._subscription.remove();_this._subscription=null;}_this._disablePolling();_context.next=8;return _regeneratorRuntime.awrap(_this.getStatusAsync());case 8:return _context.abrupt(\"return\",_context.sent);case 9:case\"end\":return _context.stop();}}});};this._pollingLoop=function _callee2(){return _regeneratorRuntime.async(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(isAudioEnabled()&&_this._canRecord&&_this._onRecordingStatusUpdate!=null)){_context2.next=10;break;}_this._progressUpdateTimeoutVariable=setTimeout(_this._pollingLoop,_this._progressUpdateIntervalMillis);_context2.prev=2;_context2.next=5;return _regeneratorRuntime.awrap(_this.getStatusAsync());case 5:_context2.next=10;break;case 7:_context2.prev=7;_context2.t0=_context2[\"catch\"](2);_this._disablePolling();case 10:case\"end\":return _context2.stop();}}},null,null,[[2,7]]);};this.getStatusAsync=function _callee3(){var status;return _regeneratorRuntime.async(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(!_this._canRecord){_context3.next=2;break;}return _context3.abrupt(\"return\",_this._performOperationAndHandleStatusAsync(function(){return ExponentAV.getAudioRecordingStatus();}));case 2:status={canRecord:false,isRecording:false,isDoneRecording:_this._isDoneRecording,durationMillis:_this._finalDurationMillis};_this._callOnRecordingStatusUpdateForNewStatus(status);return _context3.abrupt(\"return\",status);case 5:case\"end\":return _context3.stop();}}});};}_createClass(Recording,[{key:\"_disablePolling\",value:function _disablePolling(){if(this._progressUpdateTimeoutVariable!=null){clearTimeout(this._progressUpdateTimeoutVariable);this._progressUpdateTimeoutVariable=null;}}},{key:\"_enablePollingIfNecessaryAndPossible\",value:function _enablePollingIfNecessaryAndPossible(){if(isAudioEnabled()&&this._canRecord&&this._onRecordingStatusUpdate!=null){this._disablePolling();this._pollingLoop();}}},{key:\"_callOnRecordingStatusUpdateForNewStatus\",value:function _callOnRecordingStatusUpdateForNewStatus(status){if(this._onRecordingStatusUpdate!=null){this._onRecordingStatusUpdate(status);}}},{key:\"_performOperationAndHandleStatusAsync\",value:function _performOperationAndHandleStatusAsync(operation){var status;return _regeneratorRuntime.async(function _performOperationAndHandleStatusAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:throwIfAudioIsDisabled();if(!this._canRecord){_context4.next=9;break;}_context4.next=4;return _regeneratorRuntime.awrap(operation());case 4:status=_context4.sent;this._callOnRecordingStatusUpdateForNewStatus(status);return _context4.abrupt(\"return\",status);case 9:throw new Error('Cannot complete operation because this recorder is not ready to record.');case 10:case\"end\":return _context4.stop();}}},null,this);}},{key:\"setOnRecordingStatusUpdate\",value:function setOnRecordingStatusUpdate(onRecordingStatusUpdate){this._onRecordingStatusUpdate=onRecordingStatusUpdate;if(onRecordingStatusUpdate==null){this._disablePolling();}else{this._enablePollingIfNecessaryAndPossible();}this.getStatusAsync();}},{key:\"setProgressUpdateInterval\",value:function setProgressUpdateInterval(progressUpdateIntervalMillis){this._progressUpdateIntervalMillis=progressUpdateIntervalMillis;this.getStatusAsync();}},{key:\"prepareToRecordAsync\",value:function prepareToRecordAsync(){var options,extensionRegex,_ref,uri,status,currentStatus,_args5=arguments;return _regeneratorRuntime.async(function prepareToRecordAsync$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:options=_args5.length>0&&_args5[0]!==undefined?_args5[0]:RECORDING_OPTIONS_PRESET_LOW_QUALITY;throwIfAudioIsDisabled();if(!_recorderExists){_context5.next=4;break;}throw new Error('Only one Recording object can be prepared at a given time.');case 4:if(!this._isDoneRecording){_context5.next=6;break;}throw new Error('This Recording object is done recording; you must make a new one.');case 6:if(!(!options||!options.android||!options.ios)){_context5.next=8;break;}throw new Error('You must provide recording options for android and ios in order to prepare to record.');case 8:extensionRegex=/^\\.\\w+$/;if(!(!options.android.extension||!options.ios.extension||!extensionRegex.test(options.android.extension)||!extensionRegex.test(options.ios.extension))){_context5.next=11;break;}throw new Error(\"Your file extensions must match \"+extensionRegex.toString()+\".\");case 11:if(this._canRecord){_context5.next=28;break;}if(eventEmitter){this._subscription=eventEmitter.addListener('Expo.Recording.recorderUnloaded',this._cleanupForUnloadedRecorder);}_context5.next=15;return _regeneratorRuntime.awrap(ExponentAV.prepareAudioRecorder(options));case 15:_ref=_context5.sent;uri=_ref.uri;status=_ref.status;_recorderExists=true;this._uri=uri;this._options=options;this._canRecord=true;currentStatus=_objectSpread({},status,{canRecord:true});this._callOnRecordingStatusUpdateForNewStatus(currentStatus);this._enablePollingIfNecessaryAndPossible();return _context5.abrupt(\"return\",currentStatus);case 28:throw new Error('This Recording object is already prepared to record.');case 29:case\"end\":return _context5.stop();}}},null,this);}},{key:\"startAsync\",value:function startAsync(){return _regeneratorRuntime.async(function startAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:return _context6.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return ExponentAV.startAudioRecording();}));case 1:case\"end\":return _context6.stop();}}},null,this);}},{key:\"pauseAsync\",value:function pauseAsync(){return _regeneratorRuntime.async(function pauseAsync$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:return _context7.abrupt(\"return\",this._performOperationAndHandleStatusAsync(function(){return ExponentAV.pauseAudioRecording();}));case 1:case\"end\":return _context7.stop();}}},null,this);}},{key:\"stopAndUnloadAsync\",value:function stopAndUnloadAsync(){var finalStatus;return _regeneratorRuntime.async(function stopAndUnloadAsync$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:if(this._canRecord){_context8.next=6;break;}if(!this._isDoneRecording){_context8.next=5;break;}throw new Error('Cannot unload a Recording that has already been unloaded.');case 5:throw new Error('Cannot unload a Recording that has not been prepared.');case 6:_context8.next=8;return _regeneratorRuntime.awrap(ExponentAV.stopAudioRecording());case 8:finalStatus=_context8.sent;_context8.next=11;return _regeneratorRuntime.awrap(ExponentAV.unloadAudioRecorder());case 11:return _context8.abrupt(\"return\",this._cleanupForUnloadedRecorder(finalStatus));case 12:case\"end\":return _context8.stop();}}},null,this);}},{key:\"getURI\",value:function getURI(){return this._uri;}},{key:\"createNewLoadedSound\",value:function createNewLoadedSound(){var initialStatus,onPlaybackStatusUpdate,_args9=arguments;return _regeneratorRuntime.async(function createNewLoadedSound$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:initialStatus=_args9.length>0&&_args9[0]!==undefined?_args9[0]:{};onPlaybackStatusUpdate=_args9.length>1&&_args9[1]!==undefined?_args9[1]:null;console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");return _context9.abrupt(\"return\",this.createNewLoadedSoundAsync(initialStatus,onPlaybackStatusUpdate));case 4:case\"end\":return _context9.stop();}}},null,this);}},{key:\"createNewLoadedSoundAsync\",value:function createNewLoadedSoundAsync(){var initialStatus,onPlaybackStatusUpdate,_args10=arguments;return _regeneratorRuntime.async(function createNewLoadedSoundAsync$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:initialStatus=_args10.length>0&&_args10[0]!==undefined?_args10[0]:{};onPlaybackStatusUpdate=_args10.length>1&&_args10[1]!==undefined?_args10[1]:null;if(!(this._uri==null||!this._isDoneRecording)){_context10.next=4;break;}throw new Error('Cannot create sound when the Recording has not finished!');case 4:return _context10.abrupt(\"return\",Sound.createAsync({uri:this._uri},initialStatus,onPlaybackStatusUpdate,false));case 5:case\"end\":return _context10.stop();}}},null,this);}}]);return Recording;}();","map":{"version":3,"sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, Subscription, Platform } from '@unimodules/core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  PlaybackStatus,\n  PlaybackStatusToSet,\n} from '../AV';\n\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\n\nimport { Sound } from './Sound';\n\nexport type RecordingOptions = {\n  android: {\n    extension: string;\n    outputFormat: number;\n    audioEncoder: number;\n    sampleRate?: number;\n    numberOfChannels?: number;\n    bitRate?: number;\n    maxFileSize?: number;\n  };\n  ios: {\n    extension: string;\n    outputFormat?: string | number;\n    audioQuality: number;\n    sampleRate: number;\n    numberOfChannels: number;\n    bitRate: number;\n    bitRateStrategy?: number;\n    bitDepthHint?: number;\n    linearPCMBitDepth?: number;\n    linearPCMIsBigEndian?: boolean;\n    linearPCMIsFloat?: boolean;\n  };\n};\n\n// TODO: consider changing these to enums\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO: For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as\n// well?\nexport type RecordingStatus = {\n  canRecord: boolean;\n  isRecording: boolean;\n  isDoneRecording: boolean;\n  durationMillis: number;\n};\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    // $FlowFixMe(greg): durationMillis is not always defined\n    this._finalDurationMillis = finalStatus.durationMillis;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    const finalStatus = await ExponentAV.stopAudioRecording();\n    await ExponentAV.unloadAudioRecorder();\n    return this._cleanupForUnloadedRecorder(finalStatus);\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: PlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: PlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: PlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}