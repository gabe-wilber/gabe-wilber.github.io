{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _assertThisInitialized from\"@babel/runtime/helpers/assertThisInitialized\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import{Box3,Object3D}from'three';import ModelLoader from\"../../src/ModelLoader\";var Road=function(_Object3D){_inherits(Road,_Object3D);_createClass(Road,[{key:\"isFirstLane\",value:function isFirstLane(isFirst){if(isFirst){this.road.material=ModelLoader._road.models['1'].children[0].material;}else{this.road.material=ModelLoader._road.models['0'].children[0].material;}}}]);function Road(heroWidth,onCollide){var _this;_classCallCheck(this,Road);_this=_possibleConstructorReturn(this,_getPrototypeOf(Road).call(this));_this.active=false;_this.cars=[];_this.top=0.3;_this.getWidth=function(mesh){var box3=new Box3();box3.setFromObject(mesh);return Math.round(box3.max.z-box3.min.z);};_this.carGen=function(){_this.cars.map(function(val){_this.road.remove(val.mesh);val=null;});_this.cars=[];var speed=Math.random()*0.06+0.02;var numCars=Math.floor(Math.random()*2)+1;var xDir=1;if(Math.random()>0.5){xDir=-1;}var xPos=-6*xDir;for(var x=0;x<numCars;x++){if(_this.cars.length-1<x){var mesh=ModelLoader._car.getRandom();var width=_this.getWidth(mesh);_this.cars.push({mesh:mesh,dir:xDir,width:width,collisionBox:_this.heroWidth/2+width/2-0.1});_this.road.add(mesh);}_this.cars[x].mesh.position.set(xPos,0.25,0);_this.cars[x].speed=speed*xDir;_this.cars[x].mesh.rotation.y=Math.PI/2*xDir;xPos-=(Math.random()*3+5)*xDir;}};_this.update=function(dt,player){if(!_this.active){return;}_this.cars.map(function(car){return _this.drive({dt:dt,player:player,car:car});});};_this.drive=function(_ref){var dt=_ref.dt,player=_ref.player,car=_ref.car;var hitBy=player.hitBy;var offset=11;car.mesh.position.x+=car.speed;if(car.mesh.position.x>offset&&car.speed>0){car.mesh.position.x=-offset;if(car===hitBy){player.hitBy=null;}}else if(car.mesh.position.x<-offset&&car.speed<0){car.mesh.position.x=offset;if(car===hitBy){player.hitBy=null;}}else{_this.shouldCheckCollision({player:player,car:car});}};_this.shouldCheckCollision=function(_ref2){var player=_ref2.player,car=_ref2.car;if(Math.round(player.position.z)==_this.position.z&&player.isAlive){var mesh=car.mesh,collisionBox=car.collisionBox;if(player.position.x<mesh.position.x+collisionBox&&player.position.x>mesh.position.x-collisionBox){player.collideWithCar(_assertThisInitialized(_this),car);_this.onCollide(car,'feathers','car');}}};_this.heroWidth=heroWidth;_this.onCollide=onCollide;var _road=ModelLoader._road;_this.road=_road.models['1'].children[0].clone();_this.add(_this.road);_this.carGen();return _this;}return Road;}(Object3D);export{Road as default};","map":{"version":3,"sources":["/Users/gabew/Codelation-Projects/gabe-wilber.github.io/src/Row/Road.js"],"names":["Box3","Object3D","ModelLoader","Road","isFirst","road","material","_road","models","children","heroWidth","onCollide","active","cars","top","getWidth","mesh","box3","setFromObject","Math","round","max","z","min","carGen","map","val","remove","speed","random","numCars","floor","xDir","xPos","x","length","_car","getRandom","width","push","dir","collisionBox","add","position","set","rotation","y","PI","update","dt","player","car","drive","hitBy","offset","shouldCheckCollision","isAlive","collideWithCar","clone"],"mappings":"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","sourcesContent":["import { Box3, Object3D } from 'three';\n\nimport ModelLoader from '../../src/ModelLoader';\n\nexport default class Road extends Object3D {\n  active = false;\n  cars = [];\n\n  top = 0.3;\n\n  isFirstLane(isFirst) {\n    if (isFirst) {\n      this.road.material = ModelLoader._road.models['1'].children[0].material;\n    } else {\n      this.road.material = ModelLoader._road.models['0'].children[0].material;\n    }\n  }\n\n  getWidth = mesh => {\n    let box3 = new Box3();\n    box3.setFromObject(mesh);\n    // console.log( box.min, box.max, box.size() );\n    return Math.round(box3.max.z - box3.min.z);\n  };\n\n  carGen = () => {\n    this.cars.map(val => {\n      this.road.remove(val.mesh);\n      val = null;\n    });\n    this.cars = [];\n\n    // Speeds: .01 through .08\n    // Number of cars: 1 through 3\n    let speed = Math.random() * 0.06 + 0.02;\n    let numCars = Math.floor(Math.random() * 2) + 1;\n    let xDir = 1;\n\n    if (Math.random() > 0.5) {\n      xDir = -1;\n    }\n\n    let xPos = -6 * xDir;\n\n    for (let x = 0; x < numCars; x++) {\n      if (this.cars.length - 1 < x) {\n        let mesh = ModelLoader._car.getRandom();\n        const width = this.getWidth(mesh);\n\n        this.cars.push({\n          mesh,\n          dir: xDir,\n          width,\n          collisionBox: this.heroWidth / 2 + width / 2 - 0.1,\n        });\n\n        this.road.add(mesh);\n      }\n\n      this.cars[x].mesh.position.set(xPos, 0.25, 0);\n      this.cars[x].speed = speed * xDir;\n      this.cars[x].mesh.rotation.y = Math.PI / 2 * xDir;\n\n      xPos -= (Math.random() * 3 + 5) * xDir;\n    }\n  };\n\n  constructor(heroWidth, onCollide) {\n    super();\n    this.heroWidth = heroWidth;\n    this.onCollide = onCollide;\n    const { _road } = ModelLoader;\n\n    this.road = _road.models['1'].children[0].clone();\n    this.add(this.road);\n\n    this.carGen();\n  }\n\n  update = (dt, player) => {\n    if (!this.active) {\n      return;\n    }\n    this.cars.map(car => this.drive({ dt, player, car }));\n  };\n\n  drive = ({ dt, player, car }) => {\n    const { hitBy } = player;\n    const offset = 11;\n\n    car.mesh.position.x += car.speed;\n\n    if (car.mesh.position.x > offset && car.speed > 0) {\n      car.mesh.position.x = -offset;\n      if (car === hitBy) {\n        player.hitBy = null;\n      }\n    } else if (car.mesh.position.x < -offset && car.speed < 0) {\n      car.mesh.position.x = offset;\n      if (car === hitBy) {\n        player.hitBy = null;\n      }\n    } else {\n      this.shouldCheckCollision({ player, car });\n    }\n  };\n\n  shouldCheckCollision = ({ player, car }) => {\n    if (Math.round(player.position.z) == this.position.z && player.isAlive) {\n      const { mesh, collisionBox } = car;\n\n      if (\n        player.position.x < mesh.position.x + collisionBox &&\n        player.position.x > mesh.position.x - collisionBox\n      ) {\n        player.collideWithCar(this, car);\n        this.onCollide(car, 'feathers', 'car');\n      }\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}