{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import THREE from\"./Three\";export function alignMesh(mesh){var axis=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{x:0.5,y:0.5,z:0.5};var nAxis=axis||{};var box=new THREE.Box3().setFromObject(mesh);var size=new THREE.Vector3();box.getSize(size);var min={x:-box.min.x,y:-box.min.y,z:-box.min.z};for(var _i=0,_Object$keys=Object.keys(nAxis);_i<_Object$keys.length;_i++){var key=_Object$keys[_i];var scale=nAxis[key];mesh.position[key]=min[key]-size[key]+size[key]*scale;}}export function scaleLongestSideToSize(mesh,size){var sizedVector=new THREE.Vector3();new THREE.Box3().setFromObject(mesh).getSize(sizedVector);var width=sizedVector.x,height=sizedVector.y,depth=sizedVector.z;var longest=Math.max(width,Math.max(height,depth));var scale=size/longest;mesh.scale.set(scale,scale,scale);}export function computeMeshNormals(mesh){mesh.traverse(function _callee(child){var temp;return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(child instanceof THREE.Mesh){temp=toGeometry(child.geometry);temp.mergeVertices();temp.computeVertexNormals();temp.computeFaceNormals();child.geometry=new THREE.BufferGeometry().fromGeometry(temp);}case 1:case\"end\":return _context.stop();}}});});}export function toBufferGeometry(geometry){if(geometry instanceof THREE.BufferGeometry){return geometry;}var bufferGeometry=new THREE.BufferGeometry().fromGeometry(geometry);return bufferGeometry;}export function toGeometry(geometry){if(geometry instanceof THREE.Geometry){return geometry;}return new THREE.Geometry().fromBufferGeometry(geometry);}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import THREE from './Three';\n\nexport function alignMesh(mesh: THREE.Mesh, axis = { x: 0.5, y: 0.5, z: 0.5 }) {\n  const nAxis = axis || {};\n  const box = new THREE.Box3().setFromObject(mesh);\n\n  let size = new THREE.Vector3();\n  box.getSize(size);\n  const min = { x: -box.min.x, y: -box.min.y, z: -box.min.z };\n\n  for (const key of Object.keys(nAxis)) {\n    const scale = nAxis[key];\n    mesh.position[key] = min[key] - size[key] + size[key] * scale;\n  }\n}\n\nexport function scaleLongestSideToSize(mesh: THREE.Mesh, size: number) {\n  let sizedVector = new THREE.Vector3();\n  new THREE.Box3().setFromObject(mesh).getSize(sizedVector);\n\n  const { x: width, y: height, z: depth } = sizedVector;\n\n  const longest = Math.max(width, Math.max(height, depth));\n  const scale = size / longest;\n  mesh.scale.set(scale, scale, scale);\n}\n\n/** Used for smoothing imported meshes */\nexport function computeMeshNormals(mesh: THREE.Mesh) {\n  mesh.traverse(async (child: any) => {\n    if (child instanceof THREE.Mesh) {\n      /// Smooth geometry\n      const temp = toGeometry(child.geometry);\n      temp.mergeVertices();\n      temp.computeVertexNormals();\n      temp.computeFaceNormals();\n\n      child.geometry = new THREE.BufferGeometry().fromGeometry(temp);\n    }\n  });\n}\n\nexport function toBufferGeometry(\n  geometry: THREE.Geometry | THREE.BufferGeometry\n): THREE.BufferGeometry {\n  if (geometry instanceof THREE.BufferGeometry) {\n    return geometry;\n  }\n  const bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n  return bufferGeometry;\n}\n\nexport function toGeometry(\n  geometry: THREE.Geometry | THREE.BufferGeometry\n): THREE.Geometry {\n  if (geometry instanceof THREE.Geometry) {\n    return geometry;\n  }\n  return new THREE.Geometry().fromBufferGeometry(geometry);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}